
<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="never" />
    <meta property="og:description" content="一、TLD算法简介TLD(Tracking-Learning-Detection)是英国萨里大学的一个捷克籍博士生ZdenekKalal在2012年7月提出的一种新的单目标长时间跟踪算法。该算法与传统" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Tracking-Learning-Detection （TLD算法总结） - ZhangPYi - 博客园</title>
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=PEqf9X5sM-TqgxEJ-34zllMNrLPY7PzC3YhmnDnLGWA" />
    <link id="MainCss" rel="stylesheet" href="/skins/codinglife/bundle-codinglife.min.css?v=hlpQ1CJDwwJXDxv2HNauUmW3NjyWzoMaw1uER19SLT0" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/codinglife/bundle-codinglife-mobile.min.css?v=YLOkrTk5E7_pa0CoJzjGN-4x4Qir3rlm737NcHZyQvQ" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/huty/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/huty/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/huty/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=yPj1h0giSUSZPaVQJww-autD2z4394IBwpGO3oHYXMI"></script>
    <script>
        var currentBlogId = 136655;
        var currentBlogApp = 'huty';
        var cb_enable_mathjax = true;
        var isLogined = false;
    </script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processClass: 'math', processEscapes: true },
        TeX: {
        equationNumbers: { autoNumber: ['AMS'], useLabelIds: true },
        extensions: ['extpfeil.js', 'mediawiki-texvc.js'],
        Macros: {bm: "\\boldsymbol"}
        },
        'HTML-CSS': { linebreaks: { automatic: true } },
        SVG: { linebreaks: { automatic: true } }
        });
    </script>
    <script src="https://mathjax.cnblogs.com/2_7_5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
</head>
<body>
    <a name="top"></a>
    
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/huty/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/huty/">青春的纪念</a>
</h1>
<h2>

</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/huty/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/ZhangPYi">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/huty/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			
			<span id="stats_post_count">随笔 - 
2360&nbsp; </span>
<span id="stats_article_count">文章 - 
0&nbsp; </span>
<span id="stats-comment_count">评论 - 
8</span>

			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/huty/p/8519325.html">Tracking-Learning-Detection （TLD算法总结）</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                
<div id="cnblogs_post_body" class="blogpost-body ">
    
                    <link rel="stylesheet" href="http://csdnimg.cn/release/phoenix/production/htmledit_views-b569b0e3ef.css">
            <div class="htmledit_views">
                
<h1><span style="font-family:'微软雅黑';"><span style="font-size:18px;">一、TLD算法简介</span></span></h1>
<div><span style="font-size:18px;"><span style="font-family:'微软雅黑';"></span></span>
<p><span style="font-size:18px;"><span style="color:#FF0000;">TLD(Tracking-Learning-Detection)</span>是英国萨里大学的一个捷克籍博士生ZdenekKalal在2012年7月提出的一种新的单目标长时间跟踪算法。该算法与传统跟踪算法的显著区别在于<span style="color:rgb(51,51,153);">将传统的跟踪算法和传统的检测算法相结合</span>来解决被跟踪目标在被跟踪过程中发生的形变、部分遮挡等问题。同时，通过一种改进的<span style="color:rgb(51,51,153);">在线学习机制</span>不断更新跟踪模块的“显著特征点”和检测模块的目标模型及相关参数，从而使得跟踪效果更加稳定、鲁棒、可靠。</span></p>
<p></p>
<h1><span style="font-family:'微软雅黑';"><span style="font-size:18px;">二、TLD framework</span></span></h1>
<div><span style="font-size:18px;"><span style="font-family:'微软雅黑';"></span></span>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-size:18px;"><span style="font-family:'微软雅黑';">TLD是一个用于针对视频中未知物体长期跟踪的架构。简单来说，TLD算法由三部分组成：跟踪模块、检测模块、学习模块。</span><span style="color:rgb(51,51,153);">跟踪模块是观察帧与帧之间的目标的动向。<span style="color:#333399;">检测模块是把每张图看成独立的，然后去定位。</span><span style="color:#333399;">学习模块将根据跟踪模块的结果对检测模块的错误进行评估，生成训练样本来对检测模块的目标模型进行更新，避免以后出现类似错误。</span></span></span></p>
<div style="text-align:center;"><img src="" alt=""></div>
</div>
<p style="text-align:center;"><img src="http://img.blog.csdn.net/20150715210735140" alt=""><br></p>
<p><span style="font-size:18px;">TLD跟踪系统<span style="color:#333399;">最大的特点</span>就在于能对锁定的目标进行不断的学习，以获取目标最新的外观特征，从而及时完善跟踪，以达到最佳的状态。也就是说，开始时只提供一帧静止的目标图像，但随着目标的不断运动，系统能持续不断地进行探测，获知目标在角度、距离、景深等方面的改变，并实时识别，经过一段时间的学习之后，目标就再也无法躲过。</span></p>
<p><span style="font-size:18px;">TLD技术采用<span style="color:#333399;">跟踪和检测相结合</span>的策略，是一种自适应的、可靠的跟踪技术。TLD技术中，<span style="color:#FF0000;">跟踪器和检测器并行运行</span>，二者所产生的结果都参与学习过程，学习后的模型又反作用于跟踪器和检测器，对其进行实时更新，从而保证了即使在目标外观发生变化的情况下，也能够被持续跟踪。</span></p>
<span style="font-size:18px;"><br></span>
<p></p>
<h1><span style="font-family:'微软雅黑';"><span style="font-size:18px;">三、TLD算法实现</span></span></h1>
<p></p>
<p style="text-align:center;"><img src="http://img.blog.csdn.net/20150715210738728" alt=""><br></p>
<h2><span style="font-size:18px;">1. detector 检测器的实现</span></h2>
<p><span style="font-size:18px;">检测器包括三个：一是方差检测器；二是随机深林；三是最近邻分类器；</span></p>
<p><span style="font-size:18px;">step1 首先，输入一幅图，人工指定目标矩形框，然后通过在整幅图上进行扫面窗口得到一堆图像patch。</span></p>
<p><span style="font-size:18px;"><strong>扫描窗口的实现：</strong><span style="font-family:'宋体';">设定了</span><span style="font-family:Arial;">21</span><span style="font-family:'宋体';">个尺度，在选定的目标矩形框大小基础上，向上梯度</span><span style="font-family:Arial;">10</span><span style="font-family:'宋体';">个，向下梯度</span><span style="font-family:Arial;">10</span><span style="font-family:'宋体';">个。尺度梯度为</span><span style="font-family:Arial;">1.2</span><span style="font-family:'宋体';">，每个梯度下都进行窗口扫描，步进为窗口大小（宽度和高度都是</span><span style="font-family:Arial;">10%</span><span style="font-family:'宋体';">）的</span><span style="font-family:Arial;">10%</span><span style="font-family:'宋体';">，获取按照设定的扫描方式扫描得到整幅图像的</span><span style="font-family:Arial;">patch</span><span style="font-family:'宋体';">。当然大小也有限制，最小窗口尺寸为</span><span style="font-family:Arial;">15x15。</span></span></p>
<p><span style="font-family:Arial;"><span style="font-size:18px;">step 2 从patch中得到用于训练和测试的随机深林和最近邻分类器的样本。</span></span></p>
<p><span style="font-family:Arial;"><span style="font-size:18px;">选择的标准是从patch与目标矩形框的重叠度overleap，重叠度越大，越认为是正样本，重叠度越小就认为是负样本。具体的正样本和负样本见下图：</span></span></p>
<p style="text-align:center;"><img src="http://img.blog.csdn.net/20150715210741814" alt=""><br></p>
<p><span style="font-size:18px;"><span style="font-family:Arial;"></span></span></p>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-size:18px;"><span style="font-family:'宋体';">对于最近邻分类器，正样本只有一个就是</span><span style="font-family:Calibri;">best_box</span><span style="font-family:'宋体';">，即我们认为选定的或者是</span><span style="font-family:Calibri;">TLD</span><span style="font-family:'宋体';">输出的上一帧最好的结果。</span></span></p>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-family:'宋体';"><span style="font-family:Arial;"><span style="font-size:18px;">step 3 &nbsp;方差分类器</span></span></span></p>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-family:'宋体';"><span style="font-family:Arial;"><span style="font-size:18px;">利用平方积分图IIimage和积分图<span style="font-family:Arial;">Iimage</span>可快速计算任意patch的方差：var（patch） = &nbsp;<span style="font-family:Arial;">IIimage（patch）-&nbsp;<span style="font-family:Arial;">Iimage（patch）x&nbsp;<span style="font-family:Arial;">Iimage（patch）。方差小于best_box的方差50%的patch就直接淘汰。只有通过方差分类器的才能进入随机森林</span></span></span></span></span></span></p>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-family:'宋体';"><span style="font-family:Arial;"><span style="font-family:Arial;"><span style="font-family:Arial;"><span style="font-family:Arial;"><span style="font-size:18px;"><span style="font-family:Arial;">step 4 &nbsp;随机深林的训练和测试</span><br></span></span></span></span></span></span></p>
<p style="text-align:center;margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<img src="http://img.blog.csdn.net/20150715210744219" alt=""><br></p>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-family:'宋体';"><span style="font-family:Arial;"><span style="font-family:Arial;"><span style="font-family:Arial;"><span style="font-family:Arial;"><span style="font-size:18px;"><span style="font-family:Arial;"></span></span></span></span></span></span></span></p>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-size:18px;"><span style="font-family:'宋体';">这是随机深林的训练过程和测试过程：随机深林的大小为</span><span style="font-family:Arial;">10</span><span style="font-family:'宋体';">棵树，树的大小为</span><span style="font-family:Arial;">13</span><span style="font-family:'宋体';">个节点，每个节点都是一个基于像素比较的</span><span style="font-family:Arial;">decisionstump</span><span style="font-family:'宋体';">。</span><span style="font-family:Arial;">Decisionstump</span><span style="font-family:'宋体';">就是一个阈值切割，大于则为</span><span style="font-family:Arial;">1</span><span style="font-family:'宋体';">，小于则为</span><span style="font-family:Arial;">0</span><span style="font-family:'宋体';">；</span></span></p>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-size:18px;"><span style="font-family:Arial;">Decisionstump</span><span style="font-family:'宋体';">的构造是随机的选取输入</span><span style="font-family:Arial;">patch</span><span style="font-family:'宋体';">中的两点位置上的像素值进行比较，每棵树之间的</span><span style="font-family:Arial;">decisionstump</span><span style="font-family:'宋体';">选取的点是随机的，同一颗树上的</span><span style="font-family:Arial;">decisionstump</span><span style="font-family:'宋体';">也是随机的，所以称之为随机深林。但是，在随机深林初始化后，</span><span style="font-family:Arial;">forest</span><span style="font-family:'宋体';">的结构也就固定了，每次通过随机深林时所对应的</span><span style="font-family:Arial;">node</span><span style="font-family:'宋体';">节点上的</span><span style="font-family:Arial;">decision
 stump</span><span style="font-family:'宋体';">是固定的，即每一帧上对应的同一棵树上的同一个节点所代表的像素比较点的位置是固定的，因此才能进行后验概率的学习。</span></span></p>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-size:18px;"><span style="font-family:'宋体';">首先是将通过方差检测的图像</span><span style="font-family:Arial;">patch</span><span style="font-family:'宋体';">，分别输入</span><span style="font-family:Arial;">10</span><span style="font-family:'宋体';">棵树上，树的每个节点上进行一个特征的</span><span style="font-family:Arial;">decisionstump</span><span style="font-family:'宋体';">切割，最后每棵树的输出为一个</span><span style="font-family:Arial;">13</span><span style="font-family:'宋体';">位的二进制编码</span><span style="font-family:Arial;">.</span></span></p>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-size:18px;"><span style="font-family:'宋体';">利用采集到的正样本和负样本对</span><span style="font-family:Arial;">decisiontree</span><span style="font-family:'宋体';">的输出二进制值的后验概率进行学习：</span><span style="font-family:Arial;">P(y|X)=pN/(pN+nN)</span><span style="font-family:'宋体';">，有了这个我们就可以进行决策：</span><span style="font-family:Arial;">10</span><span style="font-family:'宋体';">棵树的</span><span style="font-family:Arial;">P</span><span style="font-family:'宋体';">之和与设定的阈值相比较就可以进行决策。而学习的过程就类似一个</span><span style="font-family:Arial;">perception</span><span style="font-family:'宋体';">，犯错了才进</span><span style="font-family:Arial;">P</span><span style="font-family:'宋体';">值的调整</span><span style="font-family:Arial;">(</span><span style="font-family:'宋体';">犯了漏检则增加</span><span style="font-family:Arial;">pN</span><span style="font-family:'宋体';">，犯了误检则增加</span><span style="font-family:Arial;">nN)</span><span style="font-family:'宋体';">。</span></span></p>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
</p><table border="0" cellpadding="0" cellspacing="0" width="655" style="text-align:center;"><colgroup><col width="73"><col width="125"><col width="191"><col width="121"></colgroup><tbody><tr><td>
<p><span style="font-size:18px;">y</span></p>
</td>
<td>
<p><span style="font-size:18px;">0</span></p>
</td>
<td>
<p><span style="font-size:18px;">0</span></p>
</td>
<td>
<p><span style="font-size:18px;">……</span></p>
</td>
<td>
<p><span style="font-size:18px;">0.7</span></p>
</td>
<td>
<p><span style="font-size:18px;">1</span></p>
</td>
</tr><tr><td>
<p><span style="font-size:18px;">X</span></p>
</td>
<td>
<p><span style="font-size:18px;">0</span></p>
</td>
<td>
<p><span style="font-size:18px;">1</span></p>
</td>
<td>
<p><span style="font-size:18px;">……</span></p>
</td>
<td>
<p><span style="font-size:18px;">2^13-2</span></p>
</td>
<td>
<p><span style="font-size:18px;">2^13-1</span></p>
</td>
</tr></tbody></table><span style="font-size:18px;"></span>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-size:12pt;font-family:'宋体';">比如，输入的样本为（</span><span style="font-size:12pt;font-family:Calibri;">X</span><span style="font-size:12pt;font-family:'宋体';">，</span><span style="font-size:12pt;font-family:Calibri;">1</span><span style="font-size:12pt;font-family:'宋体';">），但是却小于阈值，被判定为负样本，则说明对应的</span><span style="font-size:12pt;font-family:Calibri;">P</span><span style="font-size:12pt;font-family:'宋体';">太小，需要提高，因此对</span><span style="font-size:12pt;font-family:Calibri;">P</span><span style="font-size:12pt;font-family:'宋体';">（</span><span style="font-size:12pt;font-family:Calibri;">1|X</span><span style="font-size:12pt;font-family:'宋体';">）进行增大。</span></p>
<p><span style="color:#FF0000;">测试过程：</span></p>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-family:'宋体';">利用测试集输入到训练好的随机深林中进行测试，主要是用来调整阈值。测试集都是负样本，从而统计负样本在随机深林上的得分，取得分最高的作为阈值。（这样所有的负样本基本上是不可能通过随机深林的）</span></p>
<span style="font-family:Arial;">step 5 &nbsp;最近邻分类器的训练和测试</span><br><p><span style="font-family:Arial;"><span style="font-size:18px;"></span></span></p>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-family:'宋体';">最近邻分类器实际上就是在线的模板匹配，将输入的图像</span><span style="font-family:Arial;">patch</span><span style="font-family:'宋体';">，通过仿射变换转变为</span><span style="font-family:Arial;">15</span><span style="font-family:Arial;">*</span><span style="font-family:Arial;">15</span><span style="font-family:'宋体';">的</span><span style="font-family:Arial;">patch</span><span style="font-family:'宋体';">，并进行</span><span style="font-family:Arial;">0</span><span style="font-family:'宋体';">均值化，然后与在线的正样本模板和负样本模板进行匹配，计算对应的相关相似度和保守相似度。</span></p>
<p><span style="color:#FF0000;">最近邻分类器训练</span></p>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-family:'宋体';">最近邻分类器的训练过程其实就是更新在线模板的过程，如果输入的</span><span style="font-family:Arial;">patch</span><span style="font-family:'宋体';">为正样本，但与在线的正、负模板</span><span style="font-family:Arial;">pEx</span><span style="font-family:'宋体';">、</span><span style="font-family:Arial;">nEx</span><span style="font-family:'宋体';">的相关相似度小于阈值，则分类错误，就将该输入的</span><span style="font-family:Arial;">patch</span><span style="font-family:'宋体';">放入在线正模板</span><span style="font-family:Arial;">pEx</span><span style="font-family:'宋体';">中。如果输入的</span><span style="font-family:Arial;">patch</span><span style="font-family:'宋体';">为负样本，但与在线的正、负样本相关相似度大于阈值，则分类错误，就将该输入的</span><span style="font-family:Arial;">patch</span><span style="font-family:'宋体';">放入负样本模板</span><span style="font-family:Arial;">nEx</span><span style="font-family:'宋体';">中。效果就是动态地更新了在线模板</span></p>
<p><span style="color:#FF0000;">最近邻分类器测试</span></p>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-family:'宋体';">最近邻分类器的测试过程实际上跟随机深林的测试过程一样，为了调增对应的阈值，测试集全部是负样本，选取负样本中得到相关相似度最高的值作为最近邻分类器的分类阈值。</span></p>
<br><p><span style="font-family:Arial;"></span></p>
<h2 style="font-size:18px;"><span style="font-size:18px;">2. 中值流跟踪器的实现</span></h2>
<div style="margin-top:6.72pt;margin-bottom:0pt;margin-left:.38in;text-indent:-.38in;vertical-align:baseline;">
<span style="font-size:18px;"></span>
<p>TLD算法的<span style="color:#FF0000;">跟踪模块（Tracker）</span>，是一种在名为<span style="color:#333399;">中值流跟踪</span>（Median-Flow tracker）的跟踪方法基础上增加了<span style="color:#333399;">跟踪失败检测算法</span>的新的跟踪方法。中值流跟踪方法利用目标框来表示被跟踪目标，并在连续的相邻视频帧之间估计目标的运动。</p>
<p><span style="color:#333399;">在TLD算法中，原作者将10*10的格子中的像素点作为初始特征点，并利用金字塔LK光流法来在连续的相邻视频帧之间估计若干特征点的运动。</span></p>
<p><span style="color:#333399;"><span style="color:#FF0000;">跟踪模块的跟踪失败检测算法</span>：</span></p>
<p style="line-height:120%;margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-family:'微软雅黑';">中值流跟踪算法的前提假设是目标是可见的，所以当目标完全被遮挡或者消失于视野，则不可避免地出现跟踪失败。为了能够解决这些问题，我们采用如下策略:</span></p>
<p><span style="color:#333399;">&nbsp; &nbsp; &nbsp;让di表示其中某一个点的移动位移， &nbsp; dm表示位移中值，则残差可定义为 &nbsp; |di-dm|。如果残差大于10个像素，那么就认为跟踪失败。这个策略能够很稳定地就确定出由剧烈移动或者遮挡所造成的跟踪失败。</span></p>
</div>
<p></p>
</div>
<div style="margin-top:6.72pt;margin-bottom:0pt;margin-left:.38in;text-indent:-.38in;vertical-align:baseline;">
<span style="font-size:18px;">•<span style="font-family:'宋体';">通过前向</span><span style="font-family:Arial;">L-K</span><span style="font-family:'宋体';">金字塔光流法得到当前帧中与上一帧对应的特征点</span><span style="font-family:Arial;">points2</span><span style="font-family:'宋体';">。</span></span></div>
<div style="margin-top:6.72pt;margin-bottom:0pt;margin-left:.38in;text-indent:-.38in;vertical-align:baseline;">
<span style="font-size:18px;">•<span style="font-family:'宋体';">利用</span><span style="font-family:Arial;">points2</span><span style="font-family:'宋体';">通过反向</span><span style="font-family:Arial;">L-K</span><span style="font-family:'宋体';">金字塔光流法得到上一帧对应的特征点</span><span style="font-family:Arial;">FB_Points</span></span></div>
<div style="margin-top:6.72pt;margin-bottom:0pt;margin-left:.38in;text-indent:-.38in;vertical-align:baseline;">
<span style="font-size:18px;">•<span style="font-family:'宋体';">计算相似度</span><span style="font-family:Arial;">similarity</span><span style="font-family:'宋体';">和错误匹配度</span><span style="font-family:Arial;">FB_error</span></span></div>
<p style="margin-top:6.72pt;margin-bottom:0pt;margin-left:0in;text-indent:0in;vertical-align:baseline;">
<span style="font-size:18px;"><span style="font-family:'宋体';">获取</span><span style="font-family:Arial;">points1</span><span style="font-family:'宋体';">和</span><span style="font-family:Arial;">points2</span><span style="font-family:'宋体';">的</span><span style="font-family:Arial;">10x10</span><span style="font-family:'宋体';">亚像素精度区域，并进行像素匹配，得到匹配度作为相似度的衡量。通过计算</span><span style="font-family:Arial;">points1</span><span style="font-family:'宋体';">和</span><span style="font-family:Arial;">FB_points</span><span style="font-family:'宋体';">之间的距离，并归一化，作为错误匹配度的衡量。</span></span></p>
<div style="margin-top:6.72pt;margin-bottom:0pt;margin-left:.38in;text-indent:-.38in;vertical-align:baseline;">
<span style="font-size:18px;">•<span style="font-family:'宋体';">经过两步筛选，得到保留下的特征点</span></span></div>
<p style="margin-top:6.72pt;margin-bottom:0pt;margin-left:0in;text-indent:0in;vertical-align:baseline;">
<span style="font-size:18px;"><span style="font-family:'宋体';">剔除</span><span style="font-family:Arial;">50%</span><span style="font-family:'宋体';">相似度小的和</span><span style="font-family:Arial;">50%</span><span style="font-family:'宋体';">错误匹配度大的特征点</span></span></p>
<span style="font-size:18px;"></span>
<h2 style="font-family:Arial;font-size:18px;">3. 综合器的实现</h2>
<span style="color:#FF0000;">综合器（Integrator）</span>把检测器和跟踪器得到的目标框予以综合，并作为TLD最后的输出。如果跟踪器或者检测器都没有得到目标框，那么就认定当前帧中被跟踪目标没有出现的，否则，综合器将具有<span style="color:#333399;">最大保守相似度</span>的图像片作为最终的目标框所在位置。&nbsp;&nbsp;<br><p><span style="font-family:Arial;"><span style="font-size:18px;"></span></span></p>
<p><span style="color:#333333;">1</span><span style="color:#333333;">）先通过 重叠度 对检测器检测到的目标</span><span style="color:#333333;">boundingbox</span><span style="color:#333333;">进行聚类，每个类的重叠度小于</span><span style="color:#333333;">0.5</span><span style="color:#333333;">：</span><span style="color:#333333;">clusterConf(dbb,dconf,
 cbb, cconf);<br></span><span style="color:#333333;">（</span><span style="color:#333333;">2</span><span style="color:#333333;">）再找到与跟踪器跟踪到的</span><span style="color:#333333;">box</span><span style="color:#333333;">距离比较远的类（检测器检测到的</span><span style="color:#333333;">box</span><span style="color:#333333;">），而且它的相关相似度比跟踪器的要大：记录满足上述条件，也就是可信度比较高的目标</span><span style="color:#333333;">box</span><span style="color:#333333;">的个数：</span><span style="color:#333333;">if(bbOverlap(tbb,
 cbb[i])&lt;0.5 &amp;&amp; cconf[i]&gt;tconf)confident_detections++;<br></span><span style="color:#333333;">（</span><span style="color:#333333;">3</span><span style="color:#333333;">）判断</span><span style="color:#336699;">如果只有一个满足上述条件的</span><span style="color:#336699;">box</span><span style="color:#333333;">，那么就用这个目标</span><span style="color:#333333;">box</span><span style="color:#333333;">来重新初始化跟踪器（也就是用检测器的结果去纠正跟踪器）：</span><span style="color:#333333;">if(confident_detections==1)
 bbnext=cbb[didx];<br></span><span style="color:#333333;">（</span><span style="color:#333333;">4</span><span style="color:#333333;">）如果满足上述条件的</span><span style="color:#333333;">box</span><span style="color:#333333;">不只一个，那么就找到检测器检测到的</span><span style="color:#333333;">box</span><span style="color:#333333;">与跟踪器预测到的</span><span style="color:#333333;">box</span><span style="color:#333333;">距离很近（重叠度大于</span><span style="color:#333333;">0.7</span><span style="color:#333333;">）的所以</span><span style="color:#333333;">box</span><span style="color:#333333;">，对其坐标和大小进行累加：<br></span><span style="color:#333333;">if(bbOverlap(tbb,dbb[i])&gt;0.7)cx += dbb[i].x;……<br></span><span style="color:#333333;">（</span><span style="color:#333333;">5</span><span style="color:#333333;">）对与跟踪器预测到的</span><span style="color:#333333;">box</span><span style="color:#333333;">距离很近的</span><span style="color:#333333;">box</span><span style="color:#333333;">和跟踪器本身预测到的</span><span style="color:#333333;">box</span><span style="color:#333333;">进行坐标与大小的平均作为最终的目标</span><span style="color:#333333;">boundingbox</span><span style="color:#333333;">，但是跟踪器的权值较大：<br></span><span style="color:#333333;">bbnext.x= cvRound((float)(10*tbb.x+cx)/(float)(10+close_detections));……<br></span><span style="color:#333333;">（</span><span style="color:#333333;">6</span><span style="color:#333333;">）另外，如果跟踪器没有跟踪到目标，但是检测器检测到了一些可能的目标</span><span style="color:#333333;">box</span><span style="color:#333333;">，那么同样对其进行聚类，但只是简单的将聚类的</span><span style="color:#333333;">cbb[0]</span>作为新的跟踪目标box</p>
<h2 style="font-family:Arial;font-size:18px;">4. 学习模块的实现</h2>
<p><span style="font-size:18px;"></span></p>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-family:Arial;">Learning</span><span style="font-family:'宋体';">实际上就是重新组织正负样本对随机森林和最近邻分类器进行训练。训练的方式跟上面讲解的一样。</span></p>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="color:#FF0000;">什么时候重新组织训练呢？</span>实际上只对有跟踪结果参与的目标输出进行训练。</p>
<p style="margin-top:0pt;margin-bottom:0pt;vertical-align:baseline;">
<span style="font-family:'宋体';">对新得到的当前帧的</span><span style="font-family:Arial;">TLD</span><span style="font-family:'宋体';">目标输出</span><span style="font-family:Arial;">box</span><span style="font-family:'宋体';">进行最近邻的检测，得到与在线模型的正负模板的相关相似度，如果相关相似度比较小，或者方差比较小，或者已经在在线模型中了，就不用训练学习了。否则就在该输出的位置进行类似初始化时候的训练一样，随机深林的后验概率和最近邻分类器的在线模板进行更新。当然就没有了像初始训练中的将数据集拆分为训练集和测试集的过程了。</span></p>
<br>            </div>
                    
            
        
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2015-07-15 20:23</span>&nbsp;
<a href="https://www.cnblogs.com/huty/">ZhangPYi</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=8519325" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(8519325);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 136655, cb_blogApp = 'huty', cb_blogUserGuid = '03c06b23-6244-e211-aa8f-842b2b196315';
    var cb_entryId = 8519325, cb_entryCreatedDate = '2015-07-15 20:23', cb_postType = 1; 
    loadViewCount(cb_entryId);
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        </div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2020 ZhangPYi
<br /><span id="poweredby">Powered by .NET Core on Linux</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    
</body>
</html>